#include "test.h"

void export_FITS_file(const imaGL::CImaGL& img, std::string strFileName)
{
  //Open the file for writing
  std::ofstream of(strFileName, std::ios_base::binary | std::ios_base::out);
  using namespace imaGL;
  static auto fnMap = create_fnMap(t_nb_comp);

  int bitpix;
  long long datamin, datamax;
  switch (img.pixelsize() / img.nb_comp())
  {
  case 0:
  case 1:
    bitpix = 8;
    datamin = std::numeric_limits<uint8_t>::min();
    datamax = std::numeric_limits<uint8_t>::max();
    break;
  case 2:
    bitpix = 16;
    datamin = std::numeric_limits<int16_t>::min();
    datamax = std::numeric_limits<int16_t>::max();
    break;
  case 3: //3 ? Really ?!
    throw std::logic_error("This should not happen!");
  case 4:
    bitpix = 32;
    datamin = std::numeric_limits<int32_t>::min();
    datamax = std::numeric_limits<int32_t>::max();
    break;
  default:
    //bitpix = 64;
    //datamin = std::numeric_limits<int64_t>::min();
    //datamax = std::numeric_limits<int64_t>::max();
    throw std::logic_error("This should not happen!"); //This should not happen since the biggest pixel is UInt / RGBA --> 16/4=4
    break;
  }
  long nRecentering = 0;
  switch (img.pixeltype())
  {
  case imaGL::CImaGL::EPixelType::Float:
  case imaGL::CImaGL::EPixelType::HFloat:
    bitpix = -32;
    datamin = 0;
    datamax = 1;
    break;
  case imaGL::CImaGL::EPixelType::Byte:
    nRecentering = -std::numeric_limits<int8_t>::min();
    break;
  case imaGL::CImaGL::EPixelType::UShort:
    nRecentering = std::numeric_limits<int16_t>::min();
    break;
  case imaGL::CImaGL::EPixelType::UInt:
    nRecentering = std::numeric_limits<int32_t>::min();
    break;
  case imaGL::CImaGL::EPixelType::UInt_10_10_10_2:
  case imaGL::CImaGL::EPixelType::UInt_2_10_10_10_Rev:
    nRecentering = std::numeric_limits<int16_t>::min();
    break;
  default:
    break;
  }

  //Create Header
  std::stringstream ss;
  ss << "SIMPLE  =                    T                                                  ";
  ss << "BITPIX  = " << std::setw(20) << std::setfill(' ') << bitpix << "                                                  ";
  ss << "NAXIS   =                    3                                                  ";
  ss << "NAXIS1  = " << std::setw(20) << std::setfill(' ') << img.width() << "                                                  ";
  ss << "NAXIS2  = " << std::setw(20) << std::setfill(' ') << img.height() << "                                                  ";
  ss << "NAXIS3  = " << std::setw(20) << std::setfill(' ') << img.nb_comp() << "                                                  ";
  ss << "BZERO   =                    0                                                  ";
  ss << "BSCALE  =                    1                                                  ";
  ss << "DATAMIN = " << std::setw(20) << std::setfill(' ') << datamin << "                                                  ";
  ss << "DATAMAX = " << std::setw(20) << std::setfill(' ') << datamax << "                                                  ";
  ss << "                                                                                ";
  ss << "HISTORY THIS FITS FILE WAS GENERATED BY IMAGL TEST PROGRAM                      ";
  ss << "                                                                                ";
  ss << "COMMENT imaGL is an open source, lightweight and easy to use library to load    ";
  ss << "COMMENT images directly compatible with OpenGL functions (such as glTexImage)   ";
  ss << "                                                                                ";
  ss << "END                                                                             ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";

  of << ss.str();


  const std::byte* pData = img.pixels();
  const size_t sz = img.width() * img.height();

  size_t channelOrder[] = { 0, 1, 2, 3 };
  switch (img.pixelformat())
  {
  case imaGL::CImaGL::EPixelFormat::BGR:
  case imaGL::CImaGL::EPixelFormat::BGRA:
    channelOrder[0] = 2;
    channelOrder[2] = 0;
    break;
  default:
    break;
  }

  switch (bitpix)
  {
  case 8:
    for (size_t chan = 0; chan < img.nb_comp(); ++chan)
      for (size_t r = 0; r < img.height(); ++r) 
        for (size_t c = 0; c < img.width(); ++c)
        {
          long long val = img.long_component_at(r, c, channelOrder[chan]);
          uint8_t val2 = static_cast<uint8_t>(val + nRecentering);
          uint8_t* pByte = reinterpret_cast<uint8_t*>(&val2);
          of << pByte[0];
        }
    break;
  case 16:
    for (size_t chan = 0; chan < img.nb_comp(); ++chan)
      for (size_t r = 0; r < img.height(); ++r) 
        for (size_t c = 0; c < img.width(); ++c)
        {
          long long val = img.long_component_at(r, c, channelOrder[chan]);
          int16_t val2 = static_cast<int16_t>(val + nRecentering);
          uint8_t* pByte = reinterpret_cast<uint8_t*>(&val2);
          of << pByte[1] << pByte[0];
        }
    break;
  case 32:
    for (size_t chan = 0; chan < img.nb_comp(); ++chan)
      for (size_t r = 0; r < img.height(); ++r) 
        for (size_t c = 0; c < img.width(); ++c)
        {
          long long val = img.long_component_at(r, c, channelOrder[chan]);
          int32_t val2 = static_cast<int32_t>(val + nRecentering);
          uint8_t* pByte = reinterpret_cast<uint8_t*>(&val2);
          of << pByte[3] << pByte[2] << pByte[1] << pByte[0];
        }
    break;
  case -32:
    for (size_t chan = 0; chan < img.nb_comp(); ++chan)
      for (size_t r = 0; r < img.height(); ++r) 
        for (size_t c = 0; c < img.width(); ++c)
        {
          float val = img.float_component_at(r, c, channelOrder[chan]);
          uint8_t* pByte = reinterpret_cast<uint8_t*>(&val);
          of << pByte[3] << pByte[2] << pByte[1] << pByte[0];
        }
    break;
  case 64:
  case -64:
  default:
    throw std::logic_error("This should not happen!"); //Maximum size of a component is 4 bytes (32 bits)
    break;
  }
}

