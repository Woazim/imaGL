#include "test.h"

void export_FITS_file(const ImaGL::CImaGL& img, std::string strFileName)
{
  //Open the file for writing
  std::ofstream of(strFileName, std::ios_base::binary | std::ios_base::out);
  using namespace ImaGL;
  static auto fnMap = create_fnMap(t_nb_comp);

  int bitpix;
  long long datamin, datamax;
  switch (img.pixelsize() / img.nb_comp())
  {
  case 0:
  case 1:
    bitpix = 8;
    datamin = std::numeric_limits<unsigned char>::min();
    datamax = std::numeric_limits<unsigned char>::max();
    break;
  case 2:
    bitpix = 16;
    datamin = std::numeric_limits<int16_t>::min();
    datamax = std::numeric_limits<int16_t>::max();
    break;
  case 3: //3 ? Really ?!
    throw std::logic_error("This should not happen!");
  case 4:
    bitpix = 32;
    datamin = std::numeric_limits<int32_t>::min();
    datamax = std::numeric_limits<int32_t>::max();
    break;
  default:
    //bitpix = 64;
    //datamin = std::numeric_limits<int64_t>::min();
    //datamax = std::numeric_limits<int64_t>::max();
    throw std::logic_error("This should not happen!"); //This should not happen since the biggest pixel is UInt / RGBA --> 16/4=4
    break;
  }
  long nRecentering = 0;
  switch (img.pixeltype())
  {
  case ImaGL::CImaGL::EPixelType::Float:
  case ImaGL::CImaGL::EPixelType::HFloat:
    bitpix = -32;
    datamin = 0;
    datamax = 1;
    break;
  case ImaGL::CImaGL::EPixelType::Byte:
    nRecentering = -std::numeric_limits<char>::min();
    break;
  case ImaGL::CImaGL::EPixelType::UShort:
    nRecentering = std::numeric_limits<int16_t>::min();
    break;
  case ImaGL::CImaGL::EPixelType::UInt:
    nRecentering = std::numeric_limits<int32_t>::min();
    break;
  case ImaGL::CImaGL::EPixelType::UInt_10_10_10_2:
  case ImaGL::CImaGL::EPixelType::UInt_2_10_10_10_Rev:
    nRecentering = std::numeric_limits<int16_t>::min();
    break;
  default:
    break;
  }

  //Create Header
  std::stringstream ss;
  ss << "SIMPLE  =                    T                                                  ";
  ss << "BITPIX  = " << std::setw(20) << std::setfill(' ') << bitpix << "                                                  ";
  ss << "NAXIS   =                    3                                                  ";
  ss << "NAXIS1  = " << std::setw(20) << std::setfill(' ') << img.width() << "                                                  ";
  ss << "NAXIS2  = " << std::setw(20) << std::setfill(' ') << img.height() << "                                                  ";
  ss << "NAXIS3  = " << std::setw(20) << std::setfill(' ') << img.nb_comp() << "                                                  ";
  ss << "BZERO   =                    0                                                  ";
  ss << "BSCALE  =                    1                                                  ";
  ss << "DATAMIN = " << std::setw(20) << std::setfill(' ') << datamin << "                                                  ";
  ss << "DATAMAX = " << std::setw(20) << std::setfill(' ') << datamax << "                                                  ";
  ss << "                                                                                ";
  ss << "HISTORY THIS FITS FILE WAS GENERATED BY GIMP USING FITSRW                       ";
  ss << "                                                                                ";
  ss << "COMMENT FitsRW is (C) Peter Kirchgessner (peter@kirchgessner.net), but available";
  ss << "COMMENT under the GNU general public licence.                                   ";
  ss << "COMMENT For sources see http://www.kirchgessner.net                             ";
  ss << "                                                                                ";
  ss << "COMMENT Image type within GIMP: GIMP_RGBA_IMAGE                                 ";
  ss << "COMMENT Sequence for NAXIS3   : RED, GREEN, BLUE, ALPHA                         ";
  ss << "                                                                                ";
  ss << "END                                                                             ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";
  ss << "                                                                                ";

  of << ss.str();


  const unsigned char* pData = img.pixels();
  const size_t sz = img.width() * img.height();

  size_t channelOrder[] = { 0, 1, 2, 3 };
  switch (img.pixelformat())
  {
  case ImaGL::CImaGL::EPixelFormat::BGR:
  case ImaGL::CImaGL::EPixelFormat::BGRA:
    channelOrder[0] = 2;
    channelOrder[2] = 0;
    break;
  default:
    break;
  }

  switch (bitpix)
  {
  case 8:
    for (size_t chan = 0; chan < img.nb_comp(); ++chan)
      for (size_t r = 0; r < img.height(); ++r)
        for (size_t c = 0; c < img.width(); ++c)
        {
          long long val = img.long_component_at(r, c, channelOrder[chan]);
          uint8_t val2 = static_cast<uint8_t>(val + nRecentering);
          unsigned char* pByte = reinterpret_cast<unsigned char*>(&val2);
          of << pByte[0];
        }
    break;
  case 16:
    for (size_t chan = 0; chan < img.nb_comp(); ++chan)
      for (size_t r = 0; r < img.height(); ++r)
        for (size_t c = 0; c < img.width(); ++c)
        {
          long long val = img.long_component_at(r, c, channelOrder[chan]);
          int16_t val2 = static_cast<int16_t>(val + nRecentering);
          unsigned char* pByte = reinterpret_cast<unsigned char*>(&val2);
          of << pByte[1] << pByte[0];
        }
    break;
  case 32:
    for (size_t chan = 0; chan < img.nb_comp(); ++chan)
      for (size_t r = 0; r < img.height(); ++r)
        for (size_t c = 0; c < img.width(); ++c)
        {
          long long val = img.long_component_at(r, c, channelOrder[chan]);
          int32_t val2 = static_cast<int32_t>(val + nRecentering);
          unsigned char* pByte = reinterpret_cast<unsigned char*>(&val2);
          of << pByte[3] << pByte[2] << pByte[1] << pByte[0];
        }
    break;
  case -32:
    for (size_t chan = 0; chan < img.nb_comp(); ++chan)
      for (size_t r = 0; r < img.height(); ++r)
        for (size_t c = 0; c < img.width(); ++c)
        {
          float val = img.float_component_at(r, c, channelOrder[chan]);
          unsigned char* pByte = reinterpret_cast<unsigned char*>(&val);
          of << pByte[3] << pByte[2] << pByte[1] << pByte[0];
        }
    break;
  case 64:
  case -64:
  default:
    throw std::logic_error("This should not happen!"); //Maximum size of a component is 4 bytes (32 bits)
    break;
  }
}